{"version":3,"file":"tiny-graph.min.js","sources":["tiny-graph.js"],"names":["global","Node","value","this","edges","node","Graph","nodes","graph","prototype","constructor","adjacent","x","y","n","undefined","neighbors","Object","keys","add","del","get_node_value","set_node_value","v","get_edge_value","set_edge_value","exports","module","define"],"mappings":";;;;CAUA,SAAaA,GACb,YAQA,SAASC,MAAMC,GACdC,KAAKD,MAAQA,GAAS,KACtBC,KAAKC,SAiBN,QAASC,GAAMH,GACd,MAAO,IAAID,MAAKC,GAQjB,QAASI,SACRH,KAAKI,SAgKN,QAASC,KACR,MAAO,IAAIF,OApLZL,KAAKQ,UAAUC,YAAcT,KA2B7BK,MAAMG,UAAUC,YAAcJ,MAU9BA,MAAMG,UAAUE,SAAW,SAAUC,EAAGC,GACvC,GAAIC,GAAIX,KAAKI,MAAMK,EAEnB,OAAIE,GACmBC,SAAfD,EAAEV,MAAMS,IAGT,GAURP,MAAMG,UAAUO,UAAY,SAAUJ,GACrC,GAAIE,GAAIX,KAAKI,MAAMK,EAEnB,OAAIE,GACIG,OAAOC,KAAKJ,EAAEV,WAcvBE,MAAMG,UAAUU,IAAM,SAAUP,EAAGC,GAClC,MAAKV,MAAKI,MAAMK,IAAMT,KAAKI,MAAMM,IAChCV,KAAKI,MAAMK,GAAGR,MAAMS,GAAKV,KAAKI,MAAMM,GAAGT,MAAMQ,GAAK,MAC3C,IAGD,GAWRN,MAAMG,UAAUW,IAAM,SAAUR,EAAGC,GAClC,MAAKV,MAAKI,MAAMK,IAAMT,KAAKI,MAAMM,UACzBV,MAAKI,MAAMK,GAAGR,MAAMS,SACpBV,MAAKI,MAAMM,GAAGT,MAAMQ,IACpB,IAGD,GAURN,MAAMG,UAAUY,eAAiB,SAAUT,GAC1C,GAAIE,GAAIX,KAAKI,MAAMK,EAEnB,OAAKE,GACGA,EAAEZ,MAGHa,QAWRT,MAAMG,UAAUa,eAAiB,SAAUV,EAAGW,GAC7C,GAAIT,GAAIX,KAAKI,MAAMK,EASnB,OAPKE,GACJA,EAAEZ,MAAQqB,EAGVpB,KAAKI,MAAMK,GAAKP,EAAKkB,IAGf,GAWRjB,MAAMG,UAAUe,eAAiB,SAAUZ,EAAGC,GAC7C,GAAIC,GAAIX,KAAKI,MAAMK,EAEnB,OAAKE,IAAoBC,SAAfD,EAAEV,MAAMS,GACVC,EAAEV,MAAMS,GAGTE,QAYRT,MAAMG,UAAUgB,eAAiB,SAAUb,EAAGC,EAAGU,GAChD,MAAKpB,MAAKI,MAAMK,IAAiCG,SAA3BZ,KAAKI,MAAMK,GAAGR,MAAMS,IACzCV,KAAKI,MAAMK,GAAGR,MAAMS,GAAKV,KAAKI,MAAMM,GAAGT,MAAMQ,GAAKW,GAC3C,IAGD,GAce,mBAAXG,SACXC,OAAOD,QAAUlB,EAES,kBAAVoB,QAChBA,OAAQ,WACP,MAAOpB,KAIRR,EAAOQ,MAAQA,GAEXL","sourcesContent":["/**\n * Tiny graph data structure for Client or Server\n *\n * @author Jason Mulligan <jason.mulligan@avoidwork.com>\n * @copyright 2014 Jason Mulligan\n * @license BSD-3 <https://raw.github.com/avoidwork/tiny-graph/master/LICENSE>\n * @link http://avoidwork.github.io/tiny-graph\n * @module tiny-graph\n * @version 1.0.2\n */\n( function ( global ) {\n\"use strict\";\n\n/**\n * Node\n *\n * @param {Mixed} value [Optional] Node value\n * @constructor\n */\nfunction Node (value) {\n\tthis.value = value || null;\n\tthis.edges = {};\n}\n\n/**\n * Setting constructor loop\n *\n * @type {Object}\n */\nNode.prototype.constructor = Node;\n\n/**\n * Node factory\n *\n * @method node\n * @param {Mixed} value [Optional] Node value\n * @return {Object} Node\n */\nfunction node (value) {\n\treturn new Node(value);\n}\n\n/**\n * Graph\n *\n * @constructor\n */\nfunction Graph () {\n\tthis.nodes = {};\n}\n\n/**\n * Setting constructor loop\n *\n * @type {Object}\n */\nGraph.prototype.constructor = Graph;\n\n/**\n * Tests whether there is an edge from node `x` to node `y`\n *\n * @method adjacent\n * @param  {String} x Node\n * @param  {String} y Node\n * @return {Boolean}  `true` if there is an adjacent edge\n */\nGraph.prototype.adjacent = function (x, y) {\n\tvar n = this.nodes[x];\n\n\tif (n) {\n\t\treturn n.edges[y] !== undefined;\n\t}\n\n\treturn false;\n};\n\n/**\n * Lists all nodes `y` such that there is an edge from `x` to `y`\n *\n * @method neighbours\n * @param  {String} x Node\n * @return {Array}    Adjacent Nodes\n */\nGraph.prototype.neighbors = function (x) {\n\tvar n = this.nodes[x];\n\n\tif (n) {\n\t\treturn Object.keys(n.edges);\n\t}\n\n\treturn [];\n};\n\n/**\n * Adds the edge from `x` to `y`, if it is not there\n *\n * @method add\n * @param  {String} x Node\n * @param  {String} y Node\n * @return {Boolean}  `true` if successful, `false` if failure\n */\nGraph.prototype.add = function (x, y) {\n\tif ( this.nodes[x] && this.nodes[y] ) {\n\t\tthis.nodes[x].edges[y] = this.nodes[y].edges[x] = null;\n\t\treturn true;\n\t}\n\n\treturn false;\n};\n\n/**\n * Removes the edge from `x` to `y`, if it is there\n *\n * @method del\n * @param  {String} x Node\n * @param  {String} y Node\n * @return {Boolean}  `true` if successful, `false` if failure\n */\nGraph.prototype.del = function (x, y) {\n\tif ( this.nodes[x] && this.nodes[y] ) {\n\t\tdelete this.nodes[x].edges[y];\n\t\tdelete this.nodes[y].edges[x];\n\t\treturn true;\n\t}\n\n\treturn false;\n};\n\n/**\n * Returns the value associated with the node `x`\n *\n * @method get_node_value\n * @param  {String} x Node\n * @return {Mixed}    Value of the Node, or `undefined`\n */\nGraph.prototype.get_node_value = function (x) {\n\tvar n = this.nodes[x];\n\n\tif ( n ) {\n\t\treturn n.value;\n\t}\n\n\treturn undefined;\n};\n\n/**\n * Sets the value associated with the node `x` to `v`\n *\n * @method set_node_value\n * @param  {String} x Node\n * @param  {Mixed}  v Value\n * @return {Object}   Graph\n */\nGraph.prototype.set_node_value = function (x, v) {\n\tvar n = this.nodes[x];\n\n\tif ( n ) {\n\t\tn.value = v;\n\t}\n\telse {\n\t\tthis.nodes[x] = node(v);\n\t}\n\n\treturn true;\n};\n\n/**\n * Returns the value associated to the edge (`x`, `y`)\n *\n * @method get_edge_value\n * @param  {String} x Node\n * @param  {String} y Node\n * @return {Mixed}    Value of the edge, or `undefined`\n */\nGraph.prototype.get_edge_value = function (x, y) {\n\tvar n = this.nodes[x];\n\n\tif ( n && n.edges[y] !== undefined ) {\n\t\treturn n.edges[y];\n\t}\n\n\treturn undefined;\n};\n\n/**\n * Sets the value associated to the edge (`x`, `y`) to `v`\n *\n * @method set_edge_value\n * @param  {String} x Node\n * @param  {String} y Node\n * @param  {Mixed}  v Value\n * @return {Object}   Graph\n */\nGraph.prototype.set_edge_value = function (x, y, v) {\n\tif ( this.nodes[x] && this.nodes[x].edges[y] !== undefined ) {\n\t\tthis.nodes[x].edges[y] = this.nodes[y].edges[x] = v;\n\t\treturn true;\n\t}\n\n\treturn false;\n};\n\n/**\n * Graph factory\n *\n * @method graph\n * @return {Object} Graph\n */\nfunction graph () {\n\treturn new Graph();\n}\n\n// Node, AMD & window supported\nif ( typeof exports != \"undefined\" ) {\n\tmodule.exports = graph;\n}\nelse if ( typeof define == \"function\" ) {\n\tdefine( function () {\n\t\treturn graph;\n\t} );\n}\nelse {\n\tglobal.graph = graph;\n}\n} )( this );\n"]}