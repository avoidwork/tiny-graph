{"version":3,"file":"tiny-graph.min.js","sources":["tiny-graph.js"],"names":["global","Node","value","this","edges","node","Graph","nodes","graph","prototype","constructor","adjacent","x","y","n","undefined","neighbors","Object","keys","add","del","del_node","self","forEach","get_node_value","set_node_value","v","get_edge_value","set_edge_value","exports","module","define"],"mappings":";;;;CAUA,SAAaA,GACb,YAQA,SAASC,MAAOC,GACfC,KAAKD,MAAQA,EACbC,KAAKC,SAiBN,QAASC,GAAOH,GACf,MAAO,IAAID,MAAMC,GAQlB,QAASI,SACRH,KAAKI,SAwLN,QAASC,KACR,MAAO,IAAIF,OA5MZL,KAAKQ,UAAUC,YAAcT,KA2B7BK,MAAMG,UAAUC,YAAcJ,MAU9BA,MAAMG,UAAUE,SAAW,SAAWC,EAAGC,GACxC,GAAIC,GAAIX,KAAKI,MAAOK,EAEpB,OAAWG,UAAND,EACoBC,SAAjBD,EAAEV,MAAOS,IAGV,GAURP,MAAMG,UAAUO,UAAY,SAAWJ,GACtC,GAAIE,GAAIX,KAAKI,MAAOK,EAEpB,OAAWG,UAAND,EACGG,OAAOC,KAAMJ,EAAEV,WAcxBE,MAAMG,UAAUU,IAAM,SAAWP,EAAGC,GACnC,MAAyBE,UAApBZ,KAAKI,MAAOK,IAAyCG,SAApBZ,KAAKI,MAAOM,IACjDV,KAAKI,MAAOK,GAAIR,MAAOS,GAAMV,KAAKI,MAAOM,GAAIT,MAAOQ,GAAM,MACnD,IAGD,GAWRN,MAAMG,UAAUW,IAAM,SAAWR,EAAGC,GACnC,MAAyBE,UAApBZ,KAAKI,MAAOK,IAAoDG,SAA/BZ,KAAKI,MAAOK,GAAIR,MAAOS,UACrDV,MAAKI,MAAOK,GAAIR,MAAOS,SACvBV,MAAKI,MAAOM,GAAIT,MAAOQ,IACvB,IAGD,GAURN,MAAMG,UAAUY,SAAW,SAAWT,GACrC,GAAIU,GAAOnB,KACVW,EAAIX,KAAKI,MAAOK,EAEjB,OAAWG,UAAND,GACJG,OAAOC,KAAMJ,EAAEV,OAAQmB,QAAS,SAAWV,SACnCS,GAAKf,MAAOM,GAAIT,MAAOQ,WAExBT,MAAKI,MAAOK,IACZ,IAGD,GAURN,MAAMG,UAAUe,eAAiB,SAAWZ,GAC3C,GAAIE,GAAIX,KAAKI,MAAOK,EAEpB,OAAWG,UAAND,EACGA,EAAEZ,MAGHa,QAWRT,MAAMG,UAAUgB,eAAiB,SAAWb,EAAGc,GAC9C,GAAIZ,GAAIX,KAAKI,MAAOK,EAWpB,OATAc,GAAUX,SAANW,EAAkBA,EAAI,KAErBZ,EACJA,EAAEZ,MAAQwB,EAGVvB,KAAKI,MAAOK,GAAMP,EAAMqB,IAGlB,GAWRpB,MAAMG,UAAUkB,eAAiB,SAAWf,EAAGC,GAC9C,GAAIC,GAAIX,KAAKI,MAAOK,EAEpB,OAAWG,UAAND,GAAoCC,SAAjBD,EAAEV,MAAOS,GACzBC,EAAEV,MAAOS,GAGVE,QAYRT,MAAMG,UAAUmB,eAAiB,SAAWhB,EAAGC,EAAGa,GACjD,MAAyBX,UAApBZ,KAAKI,MAAOK,IAAoDG,SAA/BZ,KAAKI,MAAOK,GAAIR,MAAOS,IAC5DV,KAAKI,MAAOK,GAAIR,MAAOS,GAAMV,KAAKI,MAAOM,GAAIT,MAAOQ,GAAYG,SAANW,EAAkBA,EAAI,MACzE,IAGD,GAce,mBAAXG,SACXC,OAAOD,QAAUrB,EAES,kBAAVuB,QAChBA,OAAQ,WACP,MAAOvB,KAIRR,EAAOQ,MAAQA,GAEXL","sourcesContent":["/**\n * Tiny graph data structure for Client or Server\n *\n * @author Jason Mulligan <jason.mulligan@avoidwork.com>\n * @copyright 2014 Jason Mulligan\n * @license BSD-3 <https://raw.github.com/avoidwork/tiny-graph/master/LICENSE>\n * @link http://avoidwork.github.io/tiny-graph\n * @module tiny-graph\n * @version 1.0.6\n */\n( function ( global ) {\n\"use strict\";\n\n/**\n * Node\n *\n * @param {Mixed} value [Optional] Node value\n * @constructor\n */\nfunction Node ( value ) {\n\tthis.value = value;\n\tthis.edges = {};\n}\n\n/**\n * Setting constructor loop\n *\n * @type {Object}\n */\nNode.prototype.constructor = Node;\n\n/**\n * Node factory\n *\n * @method node\n * @param {Mixed} value [Optional] Node value\n * @return {Object} Node\n */\nfunction node ( value ) {\n\treturn new Node( value );\n}\n\n/**\n * Graph\n *\n * @constructor\n */\nfunction Graph () {\n\tthis.nodes = {};\n}\n\n/**\n * Setting constructor loop\n *\n * @type {Object}\n */\nGraph.prototype.constructor = Graph;\n\n/**\n * Tests whether there is an edge from node `x` to node `y`\n *\n * @method adjacent\n * @param  {String} x Node\n * @param  {String} y Node\n * @return {Boolean}  `true` if there is an adjacent edge, otherwise `false`\n */\nGraph.prototype.adjacent = function ( x, y ) {\n\tvar n = this.nodes[ x ];\n\n\tif ( n !== undefined ) {\n\t\treturn n.edges[ y ] !== undefined;\n\t}\n\n\treturn false;\n};\n\n/**\n * Lists all nodes `y` such that there is an edge from `x` to `y`\n *\n * @method neighbours\n * @param  {String} x Node\n * @return {Array}    Adjacent Nodes\n */\nGraph.prototype.neighbors = function ( x ) {\n\tvar n = this.nodes[ x ];\n\n\tif ( n !== undefined ) {\n\t\treturn Object.keys( n.edges );\n\t}\n\n\treturn [];\n};\n\n/**\n * Adds the edge from `x` to `y`, if it is not there\n *\n * @method add\n * @param  {String} x Node\n * @param  {String} y Node\n * @return {Boolean}  `true` if successful, `false` if invalid\n */\nGraph.prototype.add = function ( x, y ) {\n\tif ( this.nodes[ x ] !== undefined && this.nodes[ y ] !== undefined ) {\n\t\tthis.nodes[ x ].edges[ y ] = this.nodes[ y ].edges[ x ] = null;\n\t\treturn true;\n\t}\n\n\treturn false;\n};\n\n/**\n * Removes the edge from `x` to `y`, if it is there\n *\n * @method del\n * @param  {String} x Node\n * @param  {String} y Node\n * @return {Boolean}  `true` if successful, `false` if invalid\n */\nGraph.prototype.del = function ( x, y ) {\n\tif ( this.nodes[ x ] !== undefined && this.nodes[ x ].edges[ y ] !== undefined ) {\n\t\tdelete this.nodes[ x ].edges[ y ];\n\t\tdelete this.nodes[ y ].edges[ x ];\n\t\treturn true;\n\t}\n\n\treturn false;\n};\n\n/**\n * Removes node `x` from the graph\n *\n * @method del_node\n * @param  {String} x Node\n * @return {Boolean}  `true` if successful, `false` if invalid\n */\nGraph.prototype.del_node = function ( x ) {\n\tvar self = this,\n\t\tn = this.nodes[ x ];\n\n\tif ( n !== undefined ) {\n\t\tObject.keys( n.edges ).forEach( function ( y ) {\n\t\t\tdelete self.nodes[ y ].edges[ x ];\n\t\t} );\n\t\tdelete this.nodes[ x ];\n\t\treturn true;\n\t}\n\n\treturn false;\n};\n\n/**\n * Returns the value associated with the node `x`\n *\n * @method get_node_value\n * @param  {String} x Node\n * @return {Mixed}    Value of the Node, or `undefined`\n */\nGraph.prototype.get_node_value = function ( x ) {\n\tvar n = this.nodes[ x ];\n\n\tif ( n !== undefined ) {\n\t\treturn n.value;\n\t}\n\n\treturn undefined;\n};\n\n/**\n * Sets the value associated with the node `x` to `v`\n *\n * @method set_node_value\n * @param  {String} x Node\n * @param  {Mixed}  v Value\n * @return {Boolean}  `true`\n */\nGraph.prototype.set_node_value = function ( x, v ) {\n\tvar n = this.nodes[ x ];\n\n\tv = v !== undefined ? v : null;\n\n\tif ( n ) {\n\t\tn.value = v;\n\t}\n\telse {\n\t\tthis.nodes[ x ] = node( v );\n\t}\n\n\treturn true;\n};\n\n/**\n * Returns the value associated to the edge (`x`, `y`)\n *\n * @method get_edge_value\n * @param  {String} x Node\n * @param  {String} y Node\n * @return {Mixed}    Value of the edge, or `undefined`\n */\nGraph.prototype.get_edge_value = function ( x, y ) {\n\tvar n = this.nodes[ x ];\n\n\tif ( n !== undefined && n.edges[ y ] !== undefined ) {\n\t\treturn n.edges[ y ];\n\t}\n\n\treturn undefined;\n};\n\n/**\n * Sets the value associated to the edge (`x`, `y`) to `v`\n *\n * @method set_edge_value\n * @param  {String} x Node\n * @param  {String} y Node\n * @param  {Mixed}  v Value\n * @return {Boolean}  `true` if edge value is set, otherwise `false`\n */\nGraph.prototype.set_edge_value = function ( x, y, v ) {\n\tif ( this.nodes[ x ] !== undefined && this.nodes[ x ].edges[ y ] !== undefined ) {\n\t\tthis.nodes[ x ].edges[ y ] = this.nodes[ y ].edges[ x ] = v !== undefined ? v : null;\n\t\treturn true;\n\t}\n\n\treturn false;\n};\n\n/**\n * Graph factory\n *\n * @method graph\n * @return {Object} Graph\n */\nfunction graph () {\n\treturn new Graph();\n}\n\n// Node, AMD & window supported\nif ( typeof exports != \"undefined\" ) {\n\tmodule.exports = graph;\n}\nelse if ( typeof define == \"function\" ) {\n\tdefine( function () {\n\t\treturn graph;\n\t} );\n}\nelse {\n\tglobal.graph = graph;\n}\n} )( this );\n"]}